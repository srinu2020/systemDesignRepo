# ğŸ“¡ Distributed Real-Time Chat System - System Design

This document explains the design, architecture, and components of a real-time distributed chat system built using Node.js, WebSockets, Redis, and MongoDB.

---

## âœ… Functional Requirements

- 1-to-1 real-time chat
- Typing indicators
- Delivery and read receipts
- User online/offline status
- JWT-based authentication

---

## ğŸš« Non-Functional Requirements

- Low latency (sub-200ms)
- High availability
- Scalable (support 100K+ concurrent users)
- Secure
- Message persistence

---

## ğŸ§± High-Level Architecture



---

## ğŸ”§ Components

### 1. Client (React)
- WebSocket connection via Socket.IO
- Authenticated using JWT
- UI: chat screen, typing indicator, online status, etc.

### 2. Load Balancer (NGINX)
- Distributes WebSocket connections across server instances
- Uses sticky sessions for connection consistency

### 3. Chat Server (Node.js + Socket.IO)
- Handles WebSocket connections
- Emits/receives chat events
- Publishes/subscribes via Redis
- Persists messages in MongoDB

### 4. Redis (Pub/Sub)
- Inter-server communication for message routing
- Ensures scalability and delivery between nodes

### 5. MongoDB
- Stores all messages with metadata
- Enables chat history and offline message storage

---

## ğŸ“š Data Models

### Message Schema (MongoDB)

```json
{
  "messageId": "uuid",
  "senderId": "user123",
  "receiverId": "user456",
  "text": "Hello!",
  "timestamp": "2025-07-06T12:30:00Z",
  "delivered": true,
  "read": false
}


ğŸ”„ Message Flow (1-to-1)
User A connects to Server 1 via WebSocket

Sends message to User B

Server 1:

Saves message to MongoDB

Publishes to Redis channel user_b

Redis delivers to Server 2 (where User B is connected)

Server 2 emits to User B via WebSocket

ğŸ” Security
JWT-based user authentication

Message validation and input sanitization

HTTPS / WSS enabled

Rate limiting per connection

ğŸ§  Scalability Considerations
Area	Approach
WebSocket Scaling	Load Balancer + Sticky Sessions
Message Routing	Redis Pub/Sub
Persistence	MongoDB with indexes
Horizontal Scaling	Stateless servers, Redis bridge
Offline Users	Store and emit on reconnect

ğŸ“¦ Tech Stack
Layer	Tech
Frontend	React + Socket.IO-client
Backend	Node.js + Express + Socket.IO
Pub/Sub	Redis
Database	MongoDB
Load Balancer	NGINX
Deployment	Docker + Docker Compose
Auth	JWT

ğŸ§ª Future Improvements
Group chat and chat rooms

Chat history loading with pagination

Push notifications

Kafka instead of Redis for better reliability

Monitoring with Prometheus/Grafana



real-time-chat/
â”œâ”€â”€ client/ (React app)
â”œâ”€â”€ server/
â”‚   â”œâ”€â”€ index.js
â”‚   â”œâ”€â”€ socketHandler.js
â”‚   â”œâ”€â”€ redisClient.js
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â””â”€â”€ Message.js
â”‚   â””â”€â”€ auth/
â”‚       â””â”€â”€ jwtMiddleware.js
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ README.md
â””â”€â”€ system-design.md
